############################################################################## FILE: game.py# WRITERS: Ayal Meitar, ayal.meitar, 309981215, Shahar Nahum, shaharna13,# 313586877# EXERCISE: intro2cs ex12 2017-2018# DESCRIPTION: the file includes the class game which represents the connect# game logic, each function of the class is described below########################################################################################################################################################### imports########################################################################################################################################## Constants############################################################FIRST_COL = 0LAST_COL = 6DIAGONAL_MAX = 4WINNING_STREAK = 4DEFAULT_START_PLAYER = 0START_NUM_OF_MOVES = 0EMPTY_SPOT = NoneROW_SIZE = 6COL_SIZE = 7class Game:    """    a class that represents a four connect game    """    EXCEPTION_ILLEGAL_MOVE = "Illegal move"    PLAYER_ONE = 0    PLAYER_TWO = 1    DRAW = 2    def __init__(self):        self.__board = [[EMPTY_SPOT for col in range(COL_SIZE)] for row in                        range(ROW_SIZE)]  # An attribute that        # represents the board as a 2D.        self.__number_of_moves = START_NUM_OF_MOVES        self.__current_player = DEFAULT_START_PLAYER        self.is_game_on = True  #true while the game is on, false otherwise    def get_is_game_on(self):        """        :return: is game on        """        return self.is_game_on    def get_board(self):        """        :return: self.__board        """        return self.__board    def _is_move_legal(self, col):        """        The function receives a game and a number of col and return True if the        move is legal:        1. the col exists in the board        2. the col is not full.        :return:        """        if col > LAST_COL or col < FIRST_COL:            raise IllegalMove(self.EXCEPTION_ILLEGAL_MOVE)        if (self.__board[0][col]) != EMPTY_SPOT:            raise IllegalMove(self.EXCEPTION_ILLEGAL_MOVE)        return True    def _add_disc(self, column):        """        the function gets a game and a column chosen and adds the disc of the        current player to the matching column        :param column:        :return:        """        # goes from lowest row in to the first row        for row in range(len(self.__board) - 1, -1, -1):            if self.__board[row][column] == EMPTY_SPOT:                self.__board[row][column] = self.__current_player                return row, column    def make_move(self, column):        """        The function checks whether or not the move asked from the user is        legal. If its not legal the function will raise the exception:        "illegal move".        Else the function will make the move (update the board), update the        current player attribute and the number of turns attribute.        :param column:        :return:        """        if self._is_move_legal(column):            row, col = self._add_disc(column)            self.__number_of_moves += 1            if self.get_current_player() == Game.PLAYER_ONE:                self.__current_player = Game.PLAYER_TWO            else:  # if the value is the default one or the player two.                self.__current_player = Game.PLAYER_ONE            return row, col    @staticmethod    def _find_winner_helper(direction_lst):        """        the function checks if there is a streak of 4 discs of the same player,        meaning he won, so the function will return the winner, else it will        return None        :return:        """        for streak in direction_lst:            winning_streak_one = []            winning_streak_two = []            counter_one = 0            counter_two = 0            if len(streak) < WINNING_STREAK:                # meaning there is no win in the streak                continue            for value, location in streak:                # adds 1 to player one streak                if value == Game.PLAYER_ONE:                    winning_streak_two = []                    winning_streak_one.append(location)                    counter_one += 1                    counter_two = 0                # adds 1 to player two streak                elif value == Game.PLAYER_TWO:                    winning_streak_one = []                    winning_streak_two.append(location)                    counter_one = 0                    counter_two += 1                else:  # the value is None                    winning_streak_one = []                    winning_streak_two = []                    counter_one = 0                    counter_two = 0                if counter_two == WINNING_STREAK:                    #  checks if player one had a winning streak                    return Game.PLAYER_TWO, winning_streak_two                elif counter_one == WINNING_STREAK:                    #  checks if player two had a winning streak                    return Game.PLAYER_ONE, winning_streak_one        # if there was no wining streak        return None    def is_board_full(self):        """        the function checks whether or not the board is full.        :return:        """        for col in range(COL_SIZE):            if self.get_board()[0][col] == EMPTY_SPOT:                return False        return True    def get_winner(self):        """        the function builds a builds a list of lists for each direction.        than checks if a player won and returns the player who won, else the        function returns None        :return:        """        #  the next lines builds a list of lists for each direction        col = len(self.get_board())        row = len(self.get_board()[0])        rows = [[] for i in range(col)]        cols = [[] for i in range(row)]        forward_diag = [[] for i in range(col + row - 1)]        backwards_diag = [[] for i in range(len(forward_diag))]        min_backwards_diag = -col + 1        for y in range(col):            for x in range(row):                rows[y].append((self.get_board()[y][x], (x, y)))                cols[x].append((self.get_board()[y][x], (x, y)))                forward_diag[x + y].append((self.get_board()[y][x], (x, y)))                backwards_diag[-min_backwards_diag + x - y].append(                    (self.get_board()[y][x], (x, y)))        # for each direction using _find_winner_helper the next lines check        #  if there is a winner in one of the directions        winner = self._find_winner_helper(rows)        if winner is not None:            self.is_game_on = False            return winner        winner = self._find_winner_helper(cols)        if winner is not None:            self.is_game_on = False            return winner        winner = self._find_winner_helper(forward_diag)        if winner is not None:            self.is_game_on = False            return winner        winner = self._find_winner_helper(backwards_diag)        if winner is not None:            self.is_game_on = False            return winner        # if there is no winner and the board is full, meaning draw        if self.is_board_full():            return Game.DRAW        return None, None    def get_player_at(self, row, col):        """        the function returns the value in the matching spot        :param row:        :param col:        :return: the value in the matching spot        """        if 0 <= row < ROW_SIZE and 0 <= col < COL_SIZE:            # meaning the placement is valid            return self.__board[row][col]    def get_current_player(self):        """        :return: the current_player        """        return self.__current_playerclass IllegalMove(Exception):    """    an exception for an illegal move in the game for connect    """    pass